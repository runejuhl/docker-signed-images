#!/bin/bash
#
# Build a Docker image and sign it using GPG, adding the signature of the last
# intermediate layer to a new image. Using the new image it's possible to verify
# the author of a given Docker image without relying on external services.
#
# shellcheck disable=SC2222 disable=SC2221 disable=SC2086

set -euo pipefail

declare -a TMP_FILES=()
declare ARGS='' COMMAND='' DOCKERFILE
declare GPG="gpg ${GPG_KEY:+--default-key=$GPG_KEY}"

declare -r ACTION="${1}"
shift

function layer-get-parent() {
  docker inspect "${1}" | jq -r '.[0].Parent' | cut -d: -f2
}

function layer-get-fullhash() {
  docker inspect "${1}" | jq -r '.[0].Id' | cut -d: -f2
}

function layer-get-signature() {
  docker save "${1}" | tar axf - --to-stdout manifest.json | jq -r '.[0].Layers|.[-1]'
  docker save 908cfb54514d2636d67e1c00729784a8d1f928592fac1edcb2b32927339fafd5 | tar axf - --to-stdout 1766ac38a5f5a5d8f09ff206280b3ccda4dc0513da945f0782059ea98f66a8da/layer.tar | tar -ax .well-known/signature/8e2861e9c091cc67ab5832d459b35ac8986652e0bd2aee828214084b211e4dce.asc --to-stdout
}

function layer-compare-signature() {
  CHILD="$1"
  PARENT=$(layer-compare-signature "${CHILD}")

}

function build-get-shorthash() {
  tail -n1 | grep 'Successfully built ' | cut -d' ' -f3
}

function remove-tmp-files() {
  # FIXME: why is this var always empty?
  if [[ "${#TMP_FILES[*]}" -gt 0 ]]; then
    rm -v "${TMP_FILES[*]}"
  fi
}

function _mktemp() {
  TMP_FILE="$(mktemp ${1:+--tmpdir=${1}})"
  TMP_FILES+=("${TMP_FILE}")
  echo $TMP_FILE
}

trap remove-tmp-files INT EXIT

# loop over all arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    # if the argument is the dockerfile we set the DOCKERFILE variable and do
    # not augment the ARGS variable with this; this makes it possible for us to
    # set it later
    -f|--file)
      DOCKERFILE="${2}"
      shift 2
      ;;
    # any other argument is added to the command
    *)
      ARGS="${ARGS} ${1}"
      shift
      # if [[ $# -eq 0 ]]; then
      #   break
      # fi
      # ARGS="${ARGS} ${1}"
      ;;&
  esac
done

DOCKERFILE_DIR="$(dirname "$(readlink -f "${DOCKERFILE}")")"

case "$ACTION" in
  build)
    # docker annoyingly detects a non-interactive shell and throws away the output, so we don't have any progression information.
    >&2 echo "tmp files before: ${TMP_FILES[*]}"
    LAYER_SHORTHASH_FILE=$(_mktemp)
    COMMAND="docker ${ACTION} --file ${DOCKERFILE} ${ARGS}"
    >&2 echo "tmp files after: ${TMP_FILES[*]}"
    eval $COMMAND | pee cat "tail -n1 | grep 'Successfully built ' | cut -d' ' -f3 > ${LAYER_SHORTHASH_FILE}"
    LAYER_SIGNATURE_FILE=$(_mktemp "${DOCKERFILE_DIR}")
    LAYER_FULLHASH=$(layer-get-fullhash $(cat "${LAYER_SHORTHASH_FILE}"))
    docker save "${LAYER_FULLHASH}" | $GPG --armor --detach-sign --output - - >  "${LAYER_SIGNATURE_FILE}"

    DOCKERFILE_WITH_SIGNATURE=$(_mktemp "${DOCKERFILE_DIR}")
    cp "${DOCKERFILE}" "${DOCKERFILE_WITH_SIGNATURE}"
    cat >> "${DOCKERFILE_WITH_SIGNATURE}" <<EOF
ADD $(basename ${LAYER_SIGNATURE_FILE}) /.well-known/signature/${LAYER_FULLHASH}.asc
EOF
    docker build --file ${DOCKERFILE_WITH_SIGNATURE} ${ARGS}
    ;;
  *)
    COMMAND="docker ${ACTION} ${ARGS}"
    eval $COMMAND
    ;;
esac

>&2 echo "tmp files again: ${TMP_FILES[*]}"
